# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y1jRJvzhlUjdd66vnUOBj57YzwXHYc1s
"""

# app.py
# -*- coding: utf-8 -*-

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
from datetime import datetime, timedelta
from scipy.stats import spearmanr
import plotly.graph_objects as go
import altair as alt

# ===============================
# åŸºæœ¬è¨­å®š
# ===============================
st.set_page_config(page_title="å°ç£ ETF å€‹äººåŒ–æ¨è–¦ç³»çµ±", layout="wide")
st.title("ğŸ“Š å°ç£ ETF å€‹äººåŒ– + ç†±é–€ ETF å¤šæº–å‰‡è³‡ç”¢æ’åºæ¡†æ¶ (åƒ…ä¾›åƒè€ƒï¼Œä¸è² æŠ•è³‡é¢¨éšª:)")

TRADING_DAYS = 252
RISK_FREE_RATE = 0.01  # ç„¡é¢¨éšªåˆ©ç‡

# ===============================
# ETF Universe & å¸‚å ´åŸºæº–
# ===============================
ETF_LIST = {
    "0050.TW": "è‚¡ç¥¨å‹",
    "006208.TW": "è‚¡ç¥¨å‹",
    "00692.TW": "è‚¡ç¥¨å‹",
    "00757.TW": "è‚¡ç¥¨å‹",
    "0056.TW": "é«˜è‚¡æ¯å‹",
    "00878.TW": "é«˜è‚¡æ¯å‹",
    "00919.TW": "é«˜è‚¡æ¯å‹",
}
MARKET_BENCHMARK = "0050.TW"

# ===============================
# Sidebarï¼šä½¿ç”¨è€…è¨­å®š
# ===============================
st.sidebar.header("ğŸ‘¤ æŠ•è³‡äººé¢¨éšªè¨­å®š")
age = st.sidebar.slider("å¹´é½¡", 20, 80, 35)
horizon = st.sidebar.slider("æŠ•è³‡å¹´é™ï¼ˆå¹´ï¼‰", 1, 30, 10)
loss_tol = st.sidebar.slider("å¯æ¥å—æœ€å¤§æå¤± (%)", 0, 50, 20)
reaction = st.sidebar.radio("å¸‚å ´ä¸‹è·Œ 20% æ™‚", ["è³£å‡º", "è§€æœ›", "åŠ ç¢¼"])

theta = ((80 - age)/60 + horizon/30 + loss_tol/50 + {"è³£å‡º":0,"è§€æœ›":0.5,"åŠ ç¢¼":1}[reaction])/4
theta = np.clip(theta, 0, 1)
st.sidebar.metric("Î¸ï¼ˆé¢¨éšªåå¥½æŒ‡æ•¸ï¼‰", round(theta, 2))

def alpha_from_theta(theta, alpha_min=0.1, alpha_max=0.7):
    return alpha_min + (alpha_max - alpha_min) * theta

ALPHA_MODEL = alpha_from_theta(theta)

st.sidebar.header("âš–ï¸ ç¶œåˆåˆ†æ•¸æ¬Šé‡")
st.sidebar.write(
    f"ğŸ“Œ HotIndex æ¬Šé‡ (å…§ç”Ÿ Î±ï¼Œä¾ Î¸ è¨ˆç®—): {ALPHA_MODEL:.2f}\n"
    f"ğŸ“Œ å€‹äººåŒ–åˆ†æ•¸æ¬Šé‡: {1-ALPHA_MODEL:.2f}\n"
    "(æ‰‹å‹• slider Î± åƒ…ä¾›åƒè€ƒï¼Œä¸å½±éŸ¿æ’åº)"
)
st.sidebar.slider("HotIndex æ¬Šé‡ï¼ˆåƒ…ä¾›åƒè€ƒï¼‰", 0.0, 1.0, 0.5, step=0.05)

st.sidebar.header("ğŸ“Š æ’åºé¸æ“‡")
sort_option = st.sidebar.selectbox("é¸æ“‡æ’åºä¾æ“š", ["Final Score (HotIndex + å€‹äººåŒ–)", "é¢¨éšªé©é…åˆ†æ•¸ï¼ˆä¾ Î¸ï¼‰"])

st.sidebar.header("ğŸ“ˆ Top N ETF é¡¯ç¤º")
TOP_N = st.sidebar.slider("Top N ETF", 1, len(ETF_LIST), 5)

st.sidebar.header("ğŸ”„ å³æ™‚æ›´æ–°")
if st.sidebar.button("æ¸…é™¤å¿«å–ä¸¦æ›´æ–°å ±åƒ¹"):
    st.cache_data.clear()
    st.sidebar.success("å·²æ¸…é™¤å¿«å–ï¼Œå°‡é‡æ–°æŠ“å–å ±åƒ¹")
price_source = st.sidebar.selectbox("æœ€æ–°åƒ¹ä¾†æº", ["auto", "fast_info", "1m"], index=0)
latest_ttl = st.sidebar.slider("æœ€æ–°åƒ¹å¿«å–ç§’æ•¸", 0, 120, 10, step=5)
st.sidebar.caption("æç¤ºï¼šYahoo è³‡æ–™é€šå¸¸å»¶é²ï¼Œè‹¥éœ€æ›´å³æ™‚è«‹æ”¹ç”¨åˆ¸å•†æˆ–å®˜æ–¹ APIã€‚")


# ===============================
# æŠ“å–åƒ¹æ ¼è³‡æ–™
# ===============================

@st.cache_data(ttl=300)  # 5 åˆ†é˜
def fetch_all_price_data(etf_list, benchmark, period="1y"):
    data = {}
    tickers = list(etf_list.keys()) + [benchmark]
    for code in set(tickers):
        try:
            df = yf.Ticker(code).history(period=period)
            if not df.empty and len(df) >= 50:
                data[code] = df
        except Exception:
            data[code] = None
    return data

@st.cache_data(ttl=30)  # 30 ç§’
def fetch_latest_price(code):
    try:
        ticker = yf.Ticker(code)
        fast_info = getattr(ticker, "fast_info", None)
        if fast_info:
            for key in ("last_price", "lastPrice", "regularMarketPrice"):
                price = fast_info.get(key)
                if price:
                    return float(price)
        df = yf.download(code, period="1d", interval="1m", progress=False)
        if df is None or df.empty:
            return None
        return float(df["Close"].iloc[-1])
    except Exception:
        return None

@st.cache_data(ttl=300)  # 5 åˆ†é˜
def fetch_dividend_info(code):
    try:
        ticker = yf.Ticker(code)
        dividends = ticker.dividends
        if dividends is None or dividends.empty:
            return {"æœ€æ–°é…æ¯æ—¥": None, "æœ€è¿‘ä¸€æ¬¡é…æ¯": 0.0, "TTMé…æ¯": 0.0, "TTMæ®–åˆ©ç‡%": 0.0}
        one_year_ago = pd.Timestamp.today() - pd.DateOffset(years=1)
        ttm_dividends = dividends[dividends.index >= one_year_ago]
        latest_date = dividends.index[-1]
        latest_div = float(dividends.iloc[-1])
        price = ticker.history(period="5d")["Close"].iloc[-1]
        ttm_sum = float(ttm_dividends.sum())
        yield_ttm = (ttm_sum / price) * 100 if price > 0 else 0
        return {"æœ€æ–°é…æ¯æ—¥": latest_date.date(), "æœ€è¿‘ä¸€æ¬¡é…æ¯": round(latest_div,3),
                "TTMé…æ¯": round(ttm_sum,3), "TTMæ®–åˆ©ç‡%": round(yield_ttm,2)}
    except Exception:
        return {"æœ€æ–°é…æ¯æ—¥": None, "æœ€è¿‘ä¸€æ¬¡é…æ¯": 0.0, "TTMé…æ¯": 0.0, "TTMæ®–åˆ©ç‡%": 0.0}

# ===============================
# æŒ‡æ¨™è¨ˆç®—
# ===============================
def calc_metrics(df, market_df):
    r = df["Close"].pct_change().dropna()
    mr = market_df["Close"].pct_change().dropna()
    idx = r.index.intersection(mr.index)
    r, mr = r.loc[idx], mr.loc[idx]
    ann_ret = r.mean() * TRADING_DAYS
    ann_vol = r.std() * np.sqrt(TRADING_DAYS)
    sharpe = (ann_ret - RISK_FREE_RATE) / ann_vol if ann_vol>0 else 0
    beta = np.cov(r, mr)[0,1] / np.var(mr)
    return ann_ret*100, ann_vol*100, sharpe, beta

def compute_hot_index(df, window=20):
    volume_ma = df["Volume"].rolling(window).mean().iloc[-1]
    returns = df["Close"].pct_change()
    volatility = returns.rolling(window).std().iloc[-1]
    flow_proxy = (df["Close"]*df["Volume"]).rolling(window).mean().iloc[-1]
    return {"volume_score": volume_ma, "volatility": volatility, "flow_proxy": flow_proxy}

def robust_zscore(series):
    med = np.median(series)
    mad = np.median(np.abs(series - med))
    if mad == 0:
        return pd.Series(0, index=series.index)
    return (series - med)/mad

def compute_personalized_score(ann_ret, ann_vol, sharpe, beta, theta):
    expected_return = 5 + theta * 20
    acceptable_vol = 10 + theta * 25
    ideal_beta = 0.7 + theta * 0.8
    sharpe_fit = min(sharpe/3,1)
    return_fit = np.clip(1 - abs(ann_ret - expected_return)/expected_return,0,1)
    vol_fit = np.clip(1 - ann_vol/acceptable_vol,0,1)
    beta_fit = np.clip(1 - abs(beta - ideal_beta)/ideal_beta,0,1)
    personal_score = np.mean([sharpe_fit, return_fit, vol_fit, beta_fit])
    return {"personal_score": personal_score, "sharpe_fit":sharpe_fit, "return_fit":return_fit,
            "vol_fit":vol_fit,"beta_fit":beta_fit}

def compute_final_score(hot_index_norm, personal_score, alpha):
    return alpha*hot_index_norm + (1-alpha)*personal_score

# ===============================
# ä¸»æµç¨‹
# ===============================
price_data = fetch_all_price_data(ETF_LIST, MARKET_BENCHMARK)
market_df = price_data.get(MARKET_BENCHMARK)

rows=[]
for etf, etf_type in ETF_LIST.items():
    df = price_data.get(etf)
    if df is None or market_df is None:
        continue
    latest_price = fetch_latest_price(etf)
    if latest_price is None:
        latest_price = float(df["Close"].iloc[-1])
    ann_ret, ann_vol, sharpe, beta = calc_metrics(df, market_df)
    comp = compute_personalized_score(ann_ret, ann_vol, sharpe, beta, theta)
    risk_score = comp["vol_fit"]*0.4 + comp["beta_fit"]*0.3 + comp["return_fit"]*0.2 + comp["sharpe_fit"]*0.1
    div_info = fetch_dividend_info(etf)
    hot_metrics = compute_hot_index(df)
    row = {
        "ETF":etf, "é¡å‹":etf_type, "æœ€æ–°åƒ¹":round(latest_price,2),
        "æœ€æ–°é…æ¯æ—¥": div_info["æœ€æ–°é…æ¯æ—¥"], "æœ€è¿‘ä¸€æ¬¡é…æ¯":div_info["æœ€è¿‘ä¸€æ¬¡é…æ¯"],
        "TTMé…æ¯":div_info["TTMé…æ¯"], "TTMæ®–åˆ©ç‡%":div_info["TTMæ®–åˆ©ç‡%"],
        "Sharpe":round(sharpe,2), "Beta":round(beta,2), "å¹´åŒ–å ±é…¬%":round(ann_ret,2),
        "å¹´åŒ–æ³¢å‹•%":round(ann_vol,2), "å€‹äººåŒ–åˆ†æ•¸":round(comp["personal_score"],3),
        "é¢¨éšªé©é…åˆ†æ•¸":round(risk_score,3),
        "volume_score":hot_metrics["volume_score"], "volatility":hot_metrics["volatility"],
        "flow_proxy":hot_metrics["flow_proxy"],
        "Sharpeé©é…":round(comp["sharpe_fit"],2), "å ±é…¬é©é…":round(comp["return_fit"],2),
        "æ³¢å‹•é©é…":round(comp["vol_fit"],2), "Betaé©é…":round(comp["beta_fit"],2)
    }
    rows.append(row)

df_all = pd.DataFrame(rows)
if df_all.empty:
    st.error("ç„¡æ³•å–å¾—å³æ™‚/æ­·å²å ±åƒ¹è³‡æ–™ï¼Œè«‹ç¨å¾Œé‡è©¦æˆ–ä½¿ç”¨æ¸…é™¤å¿«å–æ›´æ–°ã€‚")
    st.stop()
df_all["hot_index"] = df_all["volume_score"] + df_all["flow_proxy"] - df_all["volatility"]
df_all["hot_index_norm"] = robust_zscore(df_all["hot_index"]).fillna(0)

# ===============================
# Î¸ æ’åº & Top-N è¡¨æ ¼
# ===============================
THETA_LIST = [0.0,0.25,0.5,0.75,1.0]
theta_rankings = {}

for t in THETA_LIST:
    rows_theta=[]
    for etf, etf_type in ETF_LIST.items():
        df = price_data.get(etf)
        if df is None or market_df is None:
            continue
        ann_ret, ann_vol, sharpe, beta = calc_metrics(df, market_df)
        comp = compute_personalized_score(ann_ret, ann_vol, sharpe, beta, t)
        final_score = compute_final_score(
            df_all.loc[df_all["ETF"]==etf, "hot_index_norm"].values[0],
            comp["personal_score"],
            ALPHA_MODEL
        )
        base_row = df_all[df_all["ETF"]==etf].iloc[0]
        row = {"ETF":etf,"é¡å‹":etf_type,"Î¸":t,"æœ€æ–°åƒ¹":base_row["æœ€æ–°åƒ¹"],
               "æœ€æ–°é…æ¯æ—¥":base_row["æœ€æ–°é…æ¯æ—¥"],"æœ€è¿‘ä¸€æ¬¡é…æ¯":base_row["æœ€è¿‘ä¸€æ¬¡é…æ¯"],
               "TTMé…æ¯":base_row["TTMé…æ¯"],"TTMæ®–åˆ©ç‡%":base_row["TTMæ®–åˆ©ç‡%"],
               "final_score":final_score,**comp,"hot_index":base_row["hot_index"]}
        rows_theta.append(row)
    df_theta = pd.DataFrame(rows_theta).sort_values("final_score", ascending=False)
    theta_rankings[t] = df_theta

theta_display_closest = min(THETA_LIST, key=lambda x: abs(x-theta))
df_ui = theta_rankings[theta_display_closest].head(TOP_N)

# ===============================
# é›·é”åœ–å°ˆç”¨è³‡æ–™
# ===============================
radar_metrics = ["sharpe_fit", "return_fit", "vol_fit", "beta_fit"]
df_radar = df_ui.copy()
for col in radar_metrics:
    min_v = df_radar[col].min()
    max_v = df_radar[col].max()
    if max_v > min_v:
        df_radar[col] = (df_radar[col] - min_v) / (max_v - min_v)
    else:
        df_radar[col] = 0.5

# ===============================
# Top-N è¡¨æ ¼
# ===============================
st.subheader(f"ğŸ¯ Top {TOP_N} ETF æ’åºï¼ˆÎ¸={round(theta,2)}, final_scoreï¼‰")
st.dataframe(
    df_ui[["ETF","é¡å‹","æœ€æ–°åƒ¹","æœ€æ–°é…æ¯æ—¥","æœ€è¿‘ä¸€æ¬¡é…æ¯",
           "TTMé…æ¯","TTMæ®–åˆ©ç‡%","final_score","personal_score",
           "sharpe_fit","return_fit","vol_fit","beta_fit","hot_index"]],
    use_container_width=True
)

# ===============================
# Top-N é›·é”åœ– (Plotly)
# ===============================
st.subheader(f"ğŸ•¸ï¸ Top {TOP_N} ETF å¤šæŒ‡æ¨™é›·é”åœ–")
radar_labels = ["Sharpe", "Return", "Volatility", "Beta"]
fig = go.Figure()
for _, row in df_radar.iterrows():
    values = [row[m] for m in radar_metrics]
    values.append(values[0])
    fig.add_trace(go.Scatterpolar(
        r=values,
        theta=radar_labels + [radar_labels[0]],
        fill="toself",
        name=row["ETF"],
        opacity=0.6
    ))
fig.update_layout(
    polar=dict(radialaxis=dict(visible=True, range=[0, 1])),
    showlegend=True,
    margin=dict(l=40, r=40, t=40, b=60)
)
st.plotly_chart(fig, use_container_width=True)

# ===============================
# Top-N æ°£æ³¡åœ– (Altair)
# ===============================
st.subheader(f"ğŸ’­ Top {TOP_N} ETF æ°£æ³¡åœ–ï¼ˆÎ¸={round(theta,2)}ï¼‰")
bubble = alt.Chart(df_ui).mark_circle(opacity=0.7, stroke="black", strokeWidth=0.5).encode(
    x=alt.X("sharpe_fit:Q", title="Sharpe é©é…"),
    y=alt.Y("personal_score:Q", title="å€‹äººåŒ–åˆ†æ•¸"),
    size=alt.Size("beta_fit:Q", title="Beta é©é…", scale=alt.Scale(range=[100,1600])),
    color=alt.Color("é¡å‹:N", title="ETF é¡å‹"),
    tooltip=["ETF","sharpe_fit","return_fit","vol_fit","beta_fit",
             "personal_score","hot_index","final_score"]
)
st.altair_chart(bubble, use_container_width=True)

# ===============================
# V2-1 éç·šæ€§è·é›¢ï¼ˆGaussian Fitï¼‰
# ===============================
def gaussian_fit(x, mu, sigma):
    if sigma <= 0: return 0.0
    return np.exp(-0.5 * ((x - mu) / sigma) ** 2)

def nonlinear_personal_score(row, theta):
    mu_ret = 5 + theta * 20
    mu_vol = 10 + theta * 25
    mu_beta = 0.7 + theta * 0.8
    ret_score = gaussian_fit(row["å¹´åŒ–å ±é…¬%"], mu_ret, mu_ret * 0.5)
    vol_score = gaussian_fit(row["å¹´åŒ–æ³¢å‹•%"], mu_vol, mu_vol * 0.5)
    beta_score = gaussian_fit(row["Beta"], mu_beta, mu_beta * 0.5)
    sharpe_score = np.tanh(row["Sharpe"] / 2)
    return np.mean([ret_score, vol_score, beta_score, sharpe_score])

def multi_period_return(df):
    closes = df["Close"]
    periods = {"3M": 63, "6M": 126, "12M": 252}
    rets = {}
    for k, p in periods.items():
        if len(closes) >= p: rets[k] = closes.iloc[-1] / closes.iloc[-p] - 1
        else: rets[k] = np.nan
    weights = {"3M":0.5,"6M":0.3,"12M":0.2}
    weighted_ret = sum(rets[k]*weights[k] for k in rets if not np.isnan(rets[k]))
    return weighted_ret * 100

def risk_distribution_metrics(df):
    r = df["Close"].pct_change().dropna()
    downside = r[r<0]
    downside_vol = downside.std()*np.sqrt(TRADING_DAYS) if len(downside)>0 else 0
    var_95 = np.percentile(r,5)
    cvar_95 = r[r<=var_95].mean()*100 if len(r[r<=var_95])>0 else 0
    return downside_vol*100, cvar_95

v2_rows=[]
for _, row in df_all.iterrows():
    etf = row["ETF"]
    df = price_data.get(etf)
    if df is None: continue
    v2_score = nonlinear_personal_score(row, theta)
    mp_ret = multi_period_return(df)
    downside_vol, cvar_95 = risk_distribution_metrics(df)
    v2_rows.append({
        "ETF":etf,
        "V2_éç·šæ€§åˆ†æ•¸": round(v2_score,3),
        "V2_å¤šæœŸé–“åŠ æ¬Šå ±é…¬%": round(mp_ret,2),
        "V2_ä¸‹è¡Œæ³¢å‹•%": round(downside_vol,2),
        "V2_CVaR_95%": round(cvar_95,2)
    })

df_v2 = pd.DataFrame(v2_rows)
df_all = df_all.merge(df_v2, on="ETF", how="left")

st.divider()
st.subheader("ğŸ§ª V2 é€²éšåˆ†æï¼ˆéç·šæ€§ Ã— å¤šæœŸé–“ Ã— é¢¨éšªåˆ†å¸ƒï¼‰")
st.caption("âš ï¸ ä»¥ä¸‹ç‚º V2 åˆ†ææ¨¡çµ„ï¼Œä¸å½±éŸ¿ä»»ä½• V1 æ’åºèˆ‡æ¨è–¦çµæœ")
st.dataframe(
    df_all[["ETF","V2_éç·šæ€§åˆ†æ•¸","V2_å¤šæœŸé–“åŠ æ¬Šå ±é…¬%",
            "V2_ä¸‹è¡Œæ³¢å‹•%","V2_CVaR_95%"]],
    use_container_width=True
)
